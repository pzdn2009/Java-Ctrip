# 类加载机制

* 什么是类的加载
* 类的生命周期
* 类加载器
* 双亲委派模型

## 什么是类的加载Loading

将.class文件的二进制数据读取到内存中，放在方法区、堆创建一个java.lang.Class对象，用来封装类在方法区的数据结构。

## 类的生命周期

Loading，Verification，Preparation，Resolution，Initialization，Using，UNloading。

* 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象。

  > 1\)通过一个类的全限定名来获取其定义的二进制字节流。 2\)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3\)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

* 验证：验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  * 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
  * 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
  * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
  * 符号引用验证：确保解析动作能正确执行。

    > 如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
* 准备。为类的静态变量分配内存，并将其初始化为默认值。准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

  > 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

* 解析：把类中的符号引用转换为直接引用

  > 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

* 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
* 初始化，为类的静态变量赋予正确的初始值

  为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

  > JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： – 创建类的实例，也就是new的方式 – 访问某个类或接口的静态变量，或者对该静态变量赋值 – 调用类的静态方法 – 反射（如Class.forName\(“com.shengsiyuan.Test”\)） – 初始化某个类的子类，则其父类也会被初始化 – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 结束生命周期 •在如下几种情况下，Java虚拟机将结束生命周期 – 执行了System.exit\(\)方法 – 程序正常执行结束 – 程序在执行过程中遇到了异常或错误而异常终止 – 由于操作系统出现错误而导致Java虚拟机进程终止

* 使用，new出对象程序中使用
* 卸载，执行垃圾回收

## 类加载器

Bootstrap, Ext, App, 自定义。

* 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib\(JDK代表JDK的安装目录，下同\)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库
* 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.\*开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器

## 双亲委派模型

双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

## 类加载机制

* 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
* 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
* 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

